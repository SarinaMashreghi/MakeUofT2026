<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cupid Bot - Robot Client</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="min-h-screen bg-gradient-to-b from-rose-50 via-white to-pink-100 text-rose-900">
    <main class="mx-auto max-w-xl px-4 py-6">
      <header class="mb-5 rounded-2xl border border-rose-200 bg-white/85 p-4 shadow">
        <h1 class="text-2xl font-bold">Cupid Bot Robot Client</h1>
        <p class="mt-1 text-sm text-rose-700">Use this on the phone mounted on the robot.</p>
        <a href="/" class="mt-3 inline-block rounded-lg bg-rose-100 px-3 py-2 text-sm font-semibold text-rose-800">
          Open Monitor View
        </a>
      </header>

      <section class="mb-4 rounded-2xl border border-rose-200 bg-white/85 p-4 shadow">
        <p class="text-sm font-semibold uppercase tracking-wide text-rose-700">Live Robot State</p>
        <p id="robot-state" class="mt-2 text-lg font-bold">Loading...</p>
      </section>

      <section class="mb-4 rounded-2xl border border-rose-200 bg-white/85 p-4 shadow">
        <p class="text-sm font-semibold uppercase tracking-wide text-rose-700">Speaker Output</p>
        <p id="latest-text" class="mt-2 text-sm text-rose-800">Waiting for speech...</p>
        <audio id="player" class="mt-3 w-full" controls autoplay></audio>
      </section>

      <section class="rounded-2xl border border-rose-200 bg-white/85 p-4 shadow">
        <p class="text-sm font-semibold uppercase tracking-wide text-rose-700">Microphone</p>
        <div class="mt-3 flex gap-2">
          <button id="record-btn" class="rounded-lg bg-rose-600 px-4 py-2 text-white">Start Recording</button>
          <button id="stop-btn" class="rounded-lg bg-rose-200 px-4 py-2 text-rose-800" disabled>Stop</button>
        </div>
        <p id="mic-status" class="mt-2 text-sm text-rose-700">Idle</p>
      </section>
    </main>

    <script>
      const robotStateEl = document.getElementById("robot-state");
      const latestTextEl = document.getElementById("latest-text");
      const playerEl = document.getElementById("player");
      const recordBtn = document.getElementById("record-btn");
      const stopBtn = document.getElementById("stop-btn");
      const micStatusEl = document.getElementById("mic-status");

      let lastAudioId = 0;
      let mediaRecorder = null;
      let chunks = [];
      let currentMood = "happy";

      function formatRobotState(state, direction) {
        if (state === "conversation_ongoing") return "Conversation ongoing (robot paused)";
        if (state === "awaiting_user_reply") return "Awaiting user reply (invite is repeating)";
        if (state === "moving_towards_target") {
          return `Moving toward target (${direction || "forward"})`;
        }
        if (state === "target_reached") return "Target reached";
        return "No target in range, searching";
      }

      async function pollStatus() {
        try {
          const res = await fetch("/status", { cache: "no-store" });
          const data = await res.json();
          robotStateEl.textContent = formatRobotState(data.robot_state, data.robot_direction);
          currentMood = data.conversation_mood || "happy";
        } catch {
          robotStateEl.textContent = "Status unavailable";
        }
      }

      async function pollLatestAudio() {
        try {
          const res = await fetch("/api/audio/latest", { cache: "no-store" });
          const data = await res.json();
          if (!data.audio_url || data.id === lastAudioId) return;

          lastAudioId = data.id;
          latestTextEl.textContent = data.text || "New audio";
          const src = `${data.audio_url}?v=${data.id}`;
          playerEl.src = src;
          try {
            await playerEl.play();
          } catch {
            // Autoplay can be blocked until user interacts on some devices.
          }
        } catch {
          // ignore transient errors
        }
      }

      recordBtn.addEventListener("click", async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorder = new MediaRecorder(stream);
          chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) chunks.push(e.data);
          };
          mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: "audio/webm" });
            const fd = new FormData();
            fd.append("audio", blob, "robot_mic.webm");
            fd.append("mood", currentMood);
            micStatusEl.textContent = "Processing...";

            try {
              const resp = await fetch("/api/process", { method: "POST", body: fd });
              const data = await resp.json();
              if (!resp.ok) {
                micStatusEl.textContent = data.error || "Processing failed";
                return;
              }
              micStatusEl.textContent = "Response generated";
              if (data.text) latestTextEl.textContent = data.text;
              if (data.audio_url) {
                playerEl.src = `${data.audio_url}?v=${Date.now()}`;
                try {
                  await playerEl.play();
                } catch {
                  // autoplay may still be blocked
                }
              }
            } catch {
              micStatusEl.textContent = "Could not reach /api/process";
            }
          };

          mediaRecorder.start();
          micStatusEl.textContent = "Recording...";
          recordBtn.disabled = true;
          stopBtn.disabled = false;
        } catch {
          micStatusEl.textContent = "Microphone permission denied";
        }
      });

      stopBtn.addEventListener("click", () => {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
          mediaRecorder.stream.getTracks().forEach((t) => t.stop());
        }
        recordBtn.disabled = false;
        stopBtn.disabled = true;
      });

      setInterval(pollStatus, 1200);
      setInterval(pollLatestAudio, 800);
      pollStatus();
      pollLatestAudio();
    </script>
  </body>
</html>
